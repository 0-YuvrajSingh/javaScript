                ğŸŸ¡ JavaScript Execution Model

âœ… Default Nature:
Synchronous: Executes one line at a time in sequence.

Single-threaded: Only one task is executed at a time.

Runs in a single execution context (one function runs at a time).

ğŸ§  Each operation waits for the previous one to finish before continuing.

ğŸ§¾ Example:

console.log(1);
console.log(2);
Output will always be 1 then 2, because itâ€™s synchronous.

ğŸ”„ Execution Environment
Memory Heap: Stores variables and data.

Call Stack: Keeps track of function calls (Last-In-First-Out).

            ğŸŸ¥ Blocking vs ğŸŸ© Non-Blocking Code
            
Blocking Code	Non-Blocking Code
âŒ Blocks the flow of program	âœ… Doesnâ€™t block the execution flow
readFileSync()	readFileAsync()
Waits for result	Registers a callback

ğŸ§  JS Engine + Event Loop (Async Handling)
ğŸ“¦ Inside the JS Engine
Memory Heap (stores data).

Call Stack (executes functions).

ğŸŒ Web API (Browser environment)
Handles DOM APIs, setTimeout, setInterval, and fetch.

After completion, it registers callbacks.

ğŸ“¤ Task Queue
Holds callbacks until the Call Stack is empty.

ğŸ” Event Loop
Continuously checks: If Call Stack is empty âœ push callback from Task Queue.

â¬†ï¸ Promise Callbacks
Sent to Microtask Queue (high priority).

Executed before Task Queue callbacks.

ğŸ” Async Flow Summary
JS encounters async code (e.g., setTimeout, fetch).

Offloaded to Web APIs.

Once ready, callback goes to Task Queue or Microtask Queue.

Event Loop adds it to Call Stack when it's empty.

Callback is executed.